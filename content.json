{"meta":{"title":"CH博客","subtitle":"停下休息的时候不要忘记别人还在奔跑。","description":"人生就像是一场旅行，不必在乎目的地，重要的是沿途的风景以及看风景的心情！","author":"超航","url":"https://jishuyao.cn","root":"/"},"pages":[{"title":"关于","date":"2022-12-19T08:43:29.165Z","updated":"2022-12-19T08:43:29.165Z","comments":false,"path":"about/index.html","permalink":"https://jishuyao.cn/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-12-19T08:43:29.165Z","updated":"2022-12-19T08:43:29.165Z","comments":false,"path":"categories/index.html","permalink":"https://jishuyao.cn/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-12-19T08:43:29.166Z","updated":"2022-12-19T08:43:29.166Z","comments":false,"path":"repository/index.html","permalink":"https://jishuyao.cn/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-12-19T08:43:29.166Z","updated":"2022-12-19T08:43:29.166Z","comments":false,"path":"tags/index.html","permalink":"https://jishuyao.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"windows笔记本电脑查看电池详细信息","slug":"windows笔记本电脑查看电池详细信息","date":"2023-01-04T08:06:06.000Z","updated":"2023-01-04T08:56:26.450Z","comments":false,"path":"2023/01/04/windows笔记本电脑查看电池详细信息/","link":"","permalink":"https://jishuyao.cn/2023/01/04/windows%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91%E6%9F%A5%E7%9C%8B%E7%94%B5%E6%B1%A0%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF/","excerpt":"","text":"按下键盘win+R键，输入cmd打开命令行窗口 在命令行窗口输入powercfg /batteryreport代码并按回车键，会出现一串路径 选中这一串路径并按Ctrl+C键复制，髯口打开此电脑，光标放到地址栏上，按下Ctrl+V键粘贴，按回车键 就会打开一个网页文件，这里显示的就是电池的详细信息","categories":[{"name":"windows","slug":"windows","permalink":"https://jishuyao.cn/categories/windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://jishuyao.cn/tags/windows/"}]},{"title":"create-react-app构建项目慢的问题","slug":"create-react-app构建项目慢的问题","date":"2022-12-21T12:52:34.000Z","updated":"2022-12-21T13:05:37.332Z","comments":false,"path":"2022/12/21/create-react-app构建项目慢的问题/","link":"","permalink":"https://jishuyao.cn/2022/12/21/create-react-app%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"npm默认的源是https://registry.npmjs.org/，地址在墙外所以会比较慢，可以采用换源的方式，换成国内淘宝的资源。 1npm config set registry https://registry.npm.taobao.org 检查是否切换成功 1npm config get registry","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://jishuyao.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"node","slug":"node","permalink":"https://jishuyao.cn/tags/node/"}]},{"title":"nodejs压缩包安装及环境配置","slug":"nodejs压缩包安装及环境配置","date":"2022-12-21T07:52:03.000Z","updated":"2022-12-21T08:13:11.098Z","comments":false,"path":"2022/12/21/nodejs压缩包安装及环境配置/","link":"","permalink":"https://jishuyao.cn/2022/12/21/nodejs%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"下载 在Node官网先下载好Node安装包，压缩包版本的，推荐下载稳定版本 安装 将压缩包文件解压缩到想要安装的目录 新建两个文件夹node_global和node_cache，用来存放全局依赖包和缓存路径 配置环境变量 将解压好的目录，根目录的路径添加到系统变量path中，就可以在任意位置使用node命令了。同时将node_global所在的目录也添加到系统变量中，这样就可以在任意位置使用全局依赖包命令了。 依次点击确定，这样node环境变量就算是配置好了，打开命令提示符窗口输入命令进行测试 查看node版本 1node -v 查看npm版本 1npm -v 像这样都打印出了版本号，环境变量就算是配置成功了。 现在设置全局依赖包和缓存路径的位置12npm config set prefix &quot;D:\\MyApps\\develops\\node-v18.12.1-win-x64\\node_global&quot;npm config set cache &quot;D:\\MyApps\\develops\\node-v18.12.1-win-x64\\node_cache&quot; 安装全局包进行测试，这里下载yarn进行测试，因为以后也会经常用到yarn的命令 1npm install yarn -g 在node_global下的node_modules这里就会有一个yarn的文件夹，说明下载成功了，位置也没问题 现在将node_modules的目录路径写入用户变量 到这里Node压缩包就安装完成了！","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://jishuyao.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Node","slug":"前端开发/Node","permalink":"https://jishuyao.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://jishuyao.cn/tags/Node/"}]},{"title":"webpack配置eslint来查找和修复 JavaScript 代码中的问题","slug":"webpack配置eslint来查找和修复 JavaScript 代码中的问题","date":"2022-12-21T06:42:12.000Z","updated":"2022-12-21T06:58:26.473Z","comments":false,"path":"2022/12/21/webpack配置eslint来查找和修复 JavaScript 代码中的问题/","link":"","permalink":"https://jishuyao.cn/2022/12/21/webpack%E9%85%8D%E7%BD%AEeslint%E6%9D%A5%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BF%AE%E5%A4%8D%20JavaScript%20%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"需要用到EslintWebpackPlugin插件，该插件使用 eslint 来查找和修复 JavaScript 代码中的问题。 安装插件首先，需要安装 eslint-webpack-plugin 1npm install eslint-webpack-plugin --save-dev 注意: 如果未安装 eslint &gt;= 7 ，你还需先通过npm安装 1npm install eslint --save-dev 在webpack配置文件中添加插件1234567const ESLintPlugin = require(&#x27;eslint-webpack-plugin&#x27;);module.exports = &#123; // ... plugins: [new ESLintPlugin(options)], // ...&#125;; options是插件中的一些配置选项，具体参数内容查看EslintWebpackPlugin配置参数 .eslintrc.js文件 写好webpack配置文件之后进行打包操作此时是报错状态，还需要在项目根目录创建.eslintrc.js文件来对eslint进行配置 12345678910111213// .eslintrc.jsmodule.exports = &#123; root: true, env: &#123; node: true, browser: true, es6: true, &#125;, rules: &#123; &#x27;no-console&#x27;: &#x27;error&#x27; &#125;&#125;; 配置项参数 root - 限定配置文件的使用范围 parser - 指定eslint的解析器 parserOptions - 设置解析器选项 extends - 指定eslint规范 plugins - 引用第三方的插件 env - 指定代码运行的宿主环境 rules - 启用额外的规则或覆盖默认的规则 globals - 声明在代码中的自定义全局变量","categories":[{"name":"webpack","slug":"webpack","permalink":"https://jishuyao.cn/categories/webpack/"}],"tags":[{"name":"前端开发","slug":"前端开发","permalink":"https://jishuyao.cn/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"webpack","slug":"webpack","permalink":"https://jishuyao.cn/tags/webpack/"}]},{"title":"基于rem和scale的屏幕适配方案","slug":"基于rem和scale的屏幕适配方案","date":"2022-12-20T06:22:48.000Z","updated":"2022-12-20T06:32:05.671Z","comments":false,"path":"2022/12/20/基于rem和scale的屏幕适配方案/","link":"","permalink":"https://jishuyao.cn/2022/12/20/%E5%9F%BA%E4%BA%8Erem%E5%92%8Cscale%E7%9A%84%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88/","excerpt":"","text":"基于rem的适配方案rem是什么？ rem是指相对于根元素的字体大小的单位，在日常开发过程中我们通常把根元素（html&#x2F;body）的字体设置为10px,方便于我们计算（此时子元素的1rem就相当于10px）。 适用场景 项目实战1、安装依赖 1npm i postcss-pxtorem autoprefixer amfe-flexible --save-dev 2、项目根目录创建 postcss.config.js 文件 1234567891011121314151617181920module.exports = &#123; plugins: &#123; autoprefixer: &#123; overrideBrowserslist: [ &quot;Android 4.1&quot;, &quot;iOS 7.1&quot;, &quot;Chrome &gt; 31&quot;, &quot;ff &gt; 31&quot;, &quot;ie &gt;= 8&quot;, &quot;last 10 versions&quot;, // 所有主流浏览器最近10版本用 ], grid: true, &#125;, &quot;postcss-pxtorem&quot;: &#123; rootValue: 192, // 设计稿宽度的1/ 10 例如设计稿按照 1920设计 此处就为192 propList: [&quot;*&quot;, &quot;!border&quot;], // 除 border 外所有px 转 rem selectorBlackList: [&quot;.el-&quot;], // 过滤掉.el-开头的class，不进行rem转换 &#125;, &#125;,&#125;; 3、main.ts/js 文件中导入依赖 1import &quot;amfe-flexible/index.js&quot;; 4、重启项目 基于scale的适配方案 在CSS3中，我们可以使用transform属性的scale()方法来实现元素的缩放效果。缩放，指的是“缩小”和“放大”的意思。 transform: scaleX(x); &#x2F; 沿x轴方向缩放&#x2F; transform: scaleY(y); &#x2F; 沿y轴方向缩放&#x2F; transform: scale(); &#x2F; 同时沿x轴和y轴缩放&#x2F; 适用场景固定宽高比的Web应用，如大屏或者固定窗口业务应用 项目实战1、新建resize.ts/js文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import &#123; ref &#125; from &quot;vue&quot;;export default function windowResize() &#123; // * 指向最外层容器 const screenRef = ref(); // * 定时函数 const timer = ref(0); // * 默认缩放值 const scale = &#123; width: &quot;1&quot;, height: &quot;1&quot;, &#125;; // * 设计稿尺寸（px） const baseWidth = 1920; const baseHeight = 1080; // * 需保持的比例（默认1.77778） const baseProportion = parseFloat((baseWidth / baseHeight).toFixed(5)); const calcRate = () =&gt; &#123; // 当前宽高比 const currentRate = parseFloat( (window.innerWidth / window.innerHeight).toFixed(5) ); if (screenRef.value) &#123; if (currentRate &gt; baseProportion) &#123; // 表示更宽 scale.width = ( (window.innerHeight * baseProportion) / baseWidth ).toFixed(5); scale.height = (window.innerHeight / baseHeight).toFixed(5); screenRef.value.style.transform = `scale($&#123;scale.width&#125;, $&#123;scale.height&#125;)`; &#125; else &#123; // 表示更高 scale.height = ( window.innerWidth / baseProportion / baseHeight ).toFixed(5); scale.width = (window.innerWidth / baseWidth).toFixed(5); screenRef.value.style.transform = `scale($&#123;scale.width&#125;, $&#123;scale.height&#125;)`; &#125; &#125; &#125;; const resize = () =&gt; &#123; clearTimeout(timer.value); timer.value = window.setTimeout(() =&gt; &#123; calcRate(); &#125;, 200); &#125;; // 改变窗口大小重新绘制 const windowDraw = () =&gt; &#123; window.addEventListener(&quot;resize&quot;, resize); &#125;; // 改变窗口大小重新绘制 const unWindowDraw = () =&gt; &#123; window.removeEventListener(&quot;resize&quot;, resize); &#125;; return &#123; screenRef, calcRate, windowDraw, unWindowDraw, &#125;;&#125; 2、相关界面引入resize.ts/js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;template&gt; &lt;div class=&quot;screen-container&quot;&gt; &lt;div class=&quot;screen-content&quot; ref=&quot;screenRef&quot;&gt; &lt;span class=&quot;screen-title&quot;&gt;基于scale的适配方案&lt;/span&gt; &lt;img class=&quot;screen-img&quot; src=&quot;https://img2.baidu.com/it/u=1297807229,3828610143&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=281&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import windowResize from &#x27;../../utils/resize&#x27;;import &#123;onMounted, onUnmounted&#125; from &#x27;vue&#x27;;const &#123; screenRef, calcRate, windowDraw, unWindowDraw &#125; = windowResize()onMounted(() =&gt; &#123; // 监听浏览器窗口尺寸变化 windowDraw() calcRate()&#125;)onUnmounted(() =&gt; &#123; unWindowDraw();&#125;)&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.screen-container &#123; height: 100%; background-color: lightcyan; display: flex; justify-content: center; align-items: center; .screen-content &#123; width: 1920px; height: 1080px; background-color: #fff; display: flex; justify-content: center; align-items: center; flex-direction: column; .screen-title &#123; font-size: 32px; &#125; .screen-img &#123; margin-top: 20px; &#125; &#125;&#125;&lt;/style&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://jishuyao.cn/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://jishuyao.cn/tags/CSS/"},{"name":"Vue","slug":"Vue","permalink":"https://jishuyao.cn/tags/Vue/"}]},{"title":"js数组去重-排序-查询-删除-json处理","slug":"js数组去重-排序-查询-删除-json处理","date":"2022-12-19T09:55:49.000Z","updated":"2022-12-19T10:07:59.592Z","comments":false,"path":"2022/12/19/js数组去重-排序-查询-删除-json处理/","link":"","permalink":"https://jishuyao.cn/2022/12/19/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D-%E6%8E%92%E5%BA%8F-%E6%9F%A5%E8%AF%A2-%E5%88%A0%E9%99%A4-json%E5%A4%84%E7%90%86/","excerpt":"","text":"数组去重1、数组对象去重-ES51234567891011121314/** * 对象数组去重 * @param &#123;any&#125; array:数组 * @param &#123;any&#125; field:去重字段 */function filterFun(array, field) &#123; let obj = &#123;&#125;; array = array.reduce((cur, next) =&gt; &#123; obj[next.id] ? &quot;&quot; : obj[next.id] = array.push(next); return cur; &#125;, []);//设置cur默认类型为数组,并且初始值为空的数组 return array;&#125; 2、数组对象去重-ES61234567/*** 对象数组去重,type表示对象里面的一个属性*/function filterFun(array, type) &#123; const map = new Map() return array.filter(item =&gt; !map.has(item[type]) &amp;&amp; map.set(item[type], 1))&#125; 排序1、日期排序123this.tableData.sort(function(a, b) &#123; return b[&#x27;datatime&#x27;] &lt; a[&#x27;datatime&#x27;] ? 1 : -1&#125;) 2、数据排序1this.tableData.sort(function(a, b) &#123; return a-b &#125;) 查询1、查询id&#x3D;999的下标1this.tableData.findIndex(item =&gt; item.id === 999) 2、查询数组对象是否存在相对于key的值123// if 可以省略var result = arr.some(item=&gt;item.name===&#x27;张三&#x27;)console.log(result) // 如果arr数组对象中含有name:&#x27;张三&#x27;,就会返回true，否则返回false 3、数组对象转换为只存在的id数组1234567//数据案例let result = [&#123;name:&#x27;张三&#x27;,id:1&#125;,&#123;name:&#x27;李四&#x27;,id:2&#125;,&#123;name:&#x27;王五&#x27;,id:3&#125;] // 我们需要获取Id [1,2,3]const newResult = result.map(item =&gt; &#123; return item.id&#125;)console.log(newResult) // [1,2,3] 4、数组opt返回中文123456789101112131415161718192021222324// 数据案例typeOpt = [ &#123; label: &#x27;见面&#x27;, value: &#x27;1&#x27; &#125;, &#123; label: &#x27;电话&#x27;, value: &#x27;2&#x27; &#125;, &#123; label: &#x27;微信&#x27;, value: &#x27;3&#x27; &#125;, &#123; label: &#x27;QQ&#x27;, value: &#x27;4&#x27; &#125;]// 我们需要的结果是 type = &#x27;1&#x27; or 我们显示的name 见面// 方法封装const typeValue = &#x27;1&#x27;/** array 当前数组对象* label 当前显示名称的key* value 当前想匹配值的key* val 当前value值*/function formatterName(array, label, value, val) &#123; let name = &#x27;&#x27; array.forEach(item =&gt; &#123; if (`$&#123;item[label]&#125;` === `$&#123;val&#125;`) &#123; name = item[value] &#125; &#125;) return name&#125;,// 调用formatterName(typeOpt,&#x27;value&#x27;,&#x27;label&#x27;,typeValue) // 结果: 见面 5、数据过滤，返回一个新数组12345678// 案例数据 const list = [&#123;name:&#x27;张三&#x27;,age:23&#125;,&#123;name:&#x27;李四&#x27;,age:21&#125;,&#123;name:&#x27;王五&#x27;,age:18&#125;,]const age = 18// 数据处理const newList = list.filter(item=&gt;&#123; return item.age &gt; age &#125;)console.log(newList) // [&#123;name:&#x27;张三&#x27;,age:23&#125;,&#123;name:&#x27;李四&#x27;,age:21&#125;] 6、数组对象过滤并且返回id123456// 数据const list = [&#123; name: &#x27;张三&#x27;, id: 23 &#125;, &#123; name: &#x27;李四&#x27;, id: 21 &#125;, &#123; name: &#x27;王五&#x27;, id: 18 &#125;]// 处理const newList = list.filter(item =&gt; &#123; return item.id &gt; 18 &#125;).map(item =&gt; &#123; return item.id &#125;)console.log(newList) // [23,21] 7、前端分页123456789const List = [1,2,3,4,5,7]List.slice((currentPage-1)*pagesize,currentPage*pagesize)//翻页设置pagesizes: [10, 20, 30,],pagesize: 15,currentPage: 1,total: 0, 删除1、根据下标删除数据1this.nodeChecked.splice(index, 1) 数据处理1、JSON数组集合生成树行解构123456789101112131415161718192021// 案例 数据const list = [ &#123; &#x27;id&#x27;: &#x27;1&#x27;, &#x27;name&#x27;: &#x27;湖北省&#x27;, &#x27;parentId&#x27;: &#x27;0&#x27;, &#x27;createUserId&#x27;: null, &#x27;createTime&#x27;: null, &#x27;updateUserId&#x27;: null, &#x27;updateTime&#x27;: null, &#x27;order&#x27;: null, &#x27;remark&#x27;: null, &#x27;code&#x27;: null, &#x27;whetherThereAreSubDepartments&#x27;: true, &#x27;superiorId&#x27;: null, &#x27;children&#x27;: null &#125;, &#123; &#x27;id&#x27;: &#x27;421000000000&#x27;, &#x27;name&#x27;: &#x27;荆州市&#x27;, &#x27;parentId&#x27;: &#x27;1&#x27;, &#x27;createUserId&#x27;: null, &#x27;createTime&#x27;: null, &#x27;updateUserId&#x27;: null, &#x27;updateTime&#x27;: null, &#x27;order&#x27;: null, &#x27;remark&#x27;: null, &#x27;code&#x27;: null, &#x27;whetherThereAreSubDepartments&#x27;: true, &#x27;superiorId&#x27;: null, &#x27;children&#x27;: null &#125;]/*** 获取xmSelect下拉菜单树 数据* @param trrData* @param id*/getTreeData(trrData, id) &#123; const _this = this const array = [] trrData.forEach(function(item, index) &#123; if ((item.parentId || 0) == id) &#123; item[&#x27;children&#x27;] = _this.getTreeData(trrData, item[&#x27;id&#x27;]) array.push(item) &#125; &#125;) return array&#125;,","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jishuyao.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jishuyao.cn/tags/JavaScript/"},{"name":"前端开发","slug":"前端开发","permalink":"https://jishuyao.cn/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}]},{"title":"React中使用Mobx","slug":"React中使用Mobx","date":"2022-12-18T14:00:33.000Z","updated":"2022-12-19T08:43:29.164Z","comments":false,"path":"2022/12/18/React中使用Mobx/","link":"","permalink":"https://jishuyao.cn/2022/12/18/React%E4%B8%AD%E4%BD%BF%E7%94%A8Mobx/","excerpt":"","text":"1、Mobx介绍 一个可以和React良好配合的集中状态管理工具，和Redux解决的问题相似，都可以独立组件进行集中状态管理 优势 简单编写无模板的极简代码精准描述你的意图 轻松实现最优渲染依赖自动追踪，实现最小渲染优化 架构自由可移植, 可测试 无特殊心智负担 社区评价 2、配置开发环境 Mobx是一个独立的响应式的库，可以独立于任何UI框架存在，但是通常大家习惯把它和React进行绑定使用，用Mobx来做响应式数据建模，React作为UI视图框架渲染内容，我们环境的配置需要三个部分 一个create-react-app创建好的React项目环境 mobx框架本身 一个用来链接mobx和React的中间件 12345# 创建项目$ yarn create vite react-mobx --template react# 安装mobx和中间件工具 mobx-react-lite 只能函数组件中使用$ yarn add mobx mobx-react-lite 3、基础使用 需求: 使用mobx实现一个计数器的案例 1、初始化mobx 初始化步骤 定义数据状态state 在构造器中实现数据响应式处理 makeAutoObservble 定义修改数据的函数action 实例化store并导出 1234567891011121314151617// counterStore.jsimport &#123; makeAutoObservable &#125; from &#x27;mobx&#x27;class CounterStore &#123; count = 0 // 定义数据 constructor() &#123; makeAutoObservable(this) // 响应式处理 &#125; // 定义修改数据的方法 addCount = () =&gt; &#123; this.count++ &#125;&#125;const counter = new CounterStore()export default counter 2、React使用store 实现步骤 在组件中导入counterStore实例对象 在组件中使用storeStore实例对象中的数据 通过事件调用修改数据的方法修改store中的数据 让组件响应数据变化 1234567891011121314151617// App.jsx// 导入counterStoreimport counterStore from &#x27;./store&#x27;// 导入observer方法import &#123; observer &#125; from &#x27;mobx-react-lite&#x27;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;button onClick=&#123;() =&gt; counterStore.addCount()&#125;&gt; &#123;counterStore.count&#125; &lt;/button&gt; &lt;/div&gt; )&#125;// 包裹组件让视图响应数据变化export default observer(App) 4、计算属性（衍生状态） 概念: 有一些状态根据现有的状态计算（衍生）得到，我们把这种状态叫做计算属性, 看下面的例子 实现步骤 声明一个存在的数据 通过get关键词 定义计算属性 在 makeAutoObservable 方法中标记计算属性 123456789101112131415161718192021222324// counterStore.jsimport &#123; computed, makeAutoObservable &#125; from &#x27;mobx&#x27;class CounterStore &#123; list = [1, 2, 3, 4, 5, 6] constructor() &#123; makeAutoObservable(this, &#123; filterList: computed &#125;) &#125; // 修改原数组 changeList = () =&gt; &#123; this.list.push(7, 8, 9) &#125; // 定义计算属性 get filterList () &#123; return this.list.filter(item =&gt; item &gt; 4) &#125;&#125;const counter = new CounterStore()export default counter 12345678910111213141516171819// App.jsx// 导入counterStoreimport counterStore from &#x27;./store&#x27;// 导入observer方法import &#123; observer &#125; from &#x27;mobx-react-lite&#x27;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &#123;/* 原数组 */&#125; &#123;JSON.stringify(counterStore.list)&#125; &#123;/* 计算属性 */&#125; &#123;JSON.stringify(counterStore.filterList)&#125; &lt;button onClick=&#123;() =&gt; counterStore.changeList()&#125;&gt;change list&lt;/button&gt; &lt;/div&gt; )&#125;// 包裹组件让视图响应数据变化export default observer(App) 5、异步数据处理 实现步骤: 在mobx中编写异步请求方法 获取数据 存入state中 组件中通过 useEffect + 空依赖 触发action函数的执行 1234567891011121314151617181920// channelStore.js// 异步的获取import &#123; makeAutoObservable &#125; from &#x27;mobx&#x27;import axios from &#x27;axios&#x27;class ChannelStore &#123; channelList = [] constructor() &#123; makeAutoObservable(this) &#125; // 只要调用这个方法 就可以从后端拿到数据并且存入channelList setChannelList = async () =&gt; &#123; const res = await axios.get(&#x27;http://xxx/api/testurl&#x27;) this.channelList = res.data.data.channels &#125;&#125;const channlStore = new ChannelStore()export default channlStore 12345678910111213141516171819202122// App.jsximport &#123; useEffect &#125; from &#x27;react&#x27;import &#123; useStore &#125; from &#x27;./store&#x27;import &#123; observer &#125; from &#x27;mobx-react-lite&#x27;function App() &#123; const &#123; channlStore &#125; = useStore() // 1. 使用数据渲染组件 // 2. 触发action函数发送异步请求 useEffect(() =&gt; &#123; channlStore.setChannelList() &#125;, []) return ( &lt;ul&gt; &#123;channlStore.channelList.map((item) =&gt; ( &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; )&#125;// 让组件可以响应数据的变化[也就是数据一变组件重新渲染]export default observer(App) 6、模块化 场景: 一个项目有很多的业务模块，我们不能把所有的代码都写到一起，这样不好维护，提了提供可维护性，需要引入模块化机制 实现步骤 拆分模块js文件，每个模块中定义自己独立的state&#x2F;action 在store&#x2F;index.js中导入拆分之后的模块，进行模块组合 利用React的context的机制导出统一的useStore方法，给业务组件使用 1-定义task模块 123456789101112131415161718// store/taskStore.jsimport &#123; makeAutoObservable &#125; from &#x27;mobx&#x27;class TaskStore &#123; taskList = [] constructor() &#123; makeAutoObservable(this) &#125; addTask () &#123; this.taskList.push(&#x27;vue&#x27;, &#x27;react&#x27;) &#125;&#125;const task = new TaskStore()export default task 2-定义counterStore 123456789101112131415161718192021222324// store/counterStore.jsimport &#123; makeAutoObservable &#125; from &#x27;mobx&#x27;class CounterStore &#123; count = 0 list = [1, 2, 3, 4, 5, 6] constructor() &#123; makeAutoObservable(this) &#125; addCount = () =&gt; &#123; this.count++ &#125; changeList = () =&gt; &#123; this.list.push(7, 8, 9) &#125; get filterList () &#123; return this.list.filter(item =&gt; item &gt; 4) &#125;&#125;const counter = new CounterStore()export default counter 3-组合模块导出统一方法 12345678910111213141516171819202122232425// store/index.jsimport React from &#x27;react&#x27;import counter from &#x27;./counterStore&#x27;import task from &#x27;./taskStore&#x27;class RootStore &#123; constructor() &#123; this.counterStore = counter this.taskStore = task &#125;&#125;const rootStore = new RootStore()// context机制的数据查找链 Provider如果找不到 就找createContext方法执行时传入的参数const context = React.createContext(rootStore)const useStore = () =&gt; React.useContext(context)// useStore() =&gt; rootStore &#123; counterStore, taskStore &#125;export &#123; useStore &#125; 4-组件使用模块中的数据 12345678910111213141516import &#123; observer &#125; from &#x27;mobx-react-lite&#x27;// 导入方法import &#123; useStore &#125; from &#x27;./store&#x27;function App() &#123; // 得到store const store = useStore() return ( &lt;div className=&quot;App&quot;&gt; &lt;button onClick=&#123;() =&gt; store.counterStore.addCount()&#125;&gt; &#123;store.counterStore.count&#125; &lt;/button&gt; &lt;/div&gt; )&#125;// 包裹组件让视图响应数据变化export default observer(App) 7、多组件共享数据 目标：当数据发生变化 所有用到数据的组件都会得到同步的组件的更新 实现步骤：在Foo组件和Bar组件中分别使用store中的数据，然后在app组件中进行数据修改，查看Foo组件和Bar组件是否得到更新 1234567891011121314151617// Bar.jsx// 用taskStore中的taskList数据import &#123; useStore &#125; from &#x27;./store&#x27;import &#123; observer &#125; from &#x27;mobx-react-lite&#x27;const Bar = () =&gt; &#123; const &#123; taskStore &#125; = useStore() return ( &lt;ul&gt; &#123;taskStore.taskList.map((item) =&gt; ( &lt;li&gt;&#123;item&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; )&#125;export default observer(Son) 1234567891011121314151617// Foo.jsx// 用taskStore中的taskList数据import &#123; useStore &#125; from &#x27;./store&#x27;import &#123; observer &#125; from &#x27;mobx-react-lite&#x27;const Bar = () =&gt; &#123; const &#123; taskStore &#125; = useStore() return ( &lt;ul&gt; &#123;taskStore.taskList.map((item) =&gt; ( &lt;li&gt;&#123;item&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; )&#125;export default observer(Son) 1234567891011121314151617// App.jsximport Bar from &#x27;./Bar&#x27;import Foo from &#x27;./Foo&#x27;import &#123; useStore &#125; from &#x27;./store&#x27;function App() &#123; const &#123; taskStore &#125; = useStore() return ( &lt;div className=&quot;App&quot;&gt; &lt;Bar /&gt; &lt;button onClick=&#123;() =&gt; taskStore.setTaskList(&#x27;angular&#x27;)&#125;&gt; 修改taskStore &lt;/button&gt; &lt;/div&gt; )&#125;export default App","categories":[{"name":"React","slug":"React","permalink":"https://jishuyao.cn/categories/React/"}],"tags":[{"name":"前端开发","slug":"前端开发","permalink":"https://jishuyao.cn/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"React","slug":"React","permalink":"https://jishuyao.cn/tags/React/"},{"name":"Mobx","slug":"Mobx","permalink":"https://jishuyao.cn/tags/Mobx/"}]},{"title":"JavaScript防抖&节流","slug":"JavaScript防抖&节流","date":"2022-12-18T13:31:39.000Z","updated":"2022-12-19T08:43:29.163Z","comments":false,"path":"2022/12/18/JavaScript防抖&节流/","link":"","permalink":"https://jishuyao.cn/2022/12/18/JavaScript%E9%98%B2%E6%8A%96&%E8%8A%82%E6%B5%81/","excerpt":"","text":"两者的作用都是为了防止函数被多次调用 防抖说明：在事件被触发n秒后在执行相应的代码，如果在这个期间内又被触发了，则重新开始计时。 代码示例： 123456789101112function debounce(fun, wait) &#123; let timeout; return function () &#123; const _that = this const args = arguments clearTimeout(timeout) timeout = setTImeout(() =&gt; &#123; fun.apply(_that, args) &#125;, wait) &#125;&#125; 节流在特定时间内只能触发一次函数，如果在这个时间内又触发了多次则不执行。 代码示例： 12345678910111213function throttle(fun, wait) &#123; let timeout return function () &#123; const _that = this const args = arguments if (!timeout) &#123; timeout = setTImeout(() =&gt; &#123; timeout = null fun.apply(_that, args) &#125;, wait) &#125; &#125;&#125;","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://jishuyao.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JavaScript","slug":"前端开发/JavaScript","permalink":"https://jishuyao.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jishuyao.cn/tags/JavaScript/"}]},{"title":"Nuxt中使用wow.js加入动画效果","slug":"Nuxt中使用wow-js加入动画效果","date":"2022-12-18T13:30:17.000Z","updated":"2022-12-19T08:43:29.164Z","comments":false,"path":"2022/12/18/Nuxt中使用wow-js加入动画效果/","link":"","permalink":"https://jishuyao.cn/2022/12/18/Nuxt%E4%B8%AD%E4%BD%BF%E7%94%A8wow-js%E5%8A%A0%E5%85%A5%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/","excerpt":"","text":"下载依赖12yarn add animate.cssyarn add wow --save 在nuxt.config.js中引入animate.css123456export default &#123; ... // Global CSS: https://go.nuxtjs.dev/config-css css: [..., &#x27;animate.css/animate.css&#x27;], ...&#125; 在需要执行动画的vue页面添加以下代码12345678910mounted () &#123; this.$nextTick(() =&gt; &#123; // eslint-disable-next-line nuxt/no-env-in-hooks // 这个注释是因为项目中如果添加了eslint后报错代码不执行，用这行注释屏蔽掉eslint if (process.browser) &#123; // 在页面mounted生命周期里面 根据环境实例化WOW // 判断是否是客户端，然后注册wow const &#123; WOW &#125; = require(&#x27;wowjs&#x27;) new WOW(&#123; animateClass: &#x27;animate__animated&#x27; &#125;).init() &#125; &#125;) &#125;, wowjs的默认配置123456789WOW.prototype.defaults = &#123; boxClass: &#x27;wow&#x27;, animateClass: &#x27;animated&#x27;, offset: 0, mobile: true, live: true, callback: null, scrollContainer: null&#125;; 属性&#x2F;方法 类型 默认值 说明 boxClass 字符串 ‘wow’ 需要执行动画的元素的 class animateClass 字符串 ‘animated’ animation.css 动画的 class offset 整数 0 距离可视区域多少开始执行动画 mobile 布尔值 true 是否在移动设备上执行动画 live 布尔值 true 异步加载的内容是否有效 默认 animateClass是animated，但是最新版本的animate.css中的class都是以 animate__ 开头,所以我们需要把默认值 animateClass: ‘animated’ 改为 animateClass: ‘animate__animated’，这样动画才会生效。 使用在需要动画的标签class中添加wow，然后再添加一个animate.css的动画，就可以了。 其他配置项： data-wow-duration：更改动画持续时间 data-wow-delay：动画开始前的延迟 data-wow-offset：开始动画的距离（与浏览器底部相关） data-wow-iteration：动画的次数重复（无限次：infinite） 类名控制： Example animate__slow：用2s执行完 animate__slower：用3s执行 animate__fast：用800ms执行完 animate__faster：用500ms执行完 animate__infinite：无限循环","categories":[{"name":"SSR","slug":"SSR","permalink":"https://jishuyao.cn/categories/SSR/"}],"tags":[{"name":"Nuxt","slug":"Nuxt","permalink":"https://jishuyao.cn/tags/Nuxt/"}]},{"title":"Nuxt中使用CSS预处理器","slug":"Nuxt中使用CSS预处理器","date":"2022-12-18T13:29:20.000Z","updated":"2022-12-19T08:43:29.163Z","comments":false,"path":"2022/12/18/Nuxt中使用CSS预处理器/","link":"","permalink":"https://jishuyao.cn/2022/12/18/Nuxt%E4%B8%AD%E4%BD%BF%E7%94%A8CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/","excerpt":"","text":"less安装依赖 npm 12npm install less less-loader --savenpm install @nuxtjs/style-resources --save yarn 12yarn add less-loader lessyarn add @nuxtjs/style-resources 配置 添加@nuxtjs&#x2F;style-resources模块和全局样式文件 12345678910export default &#123; ... modules: [ &#x27;@nuxtjs/style-resources&#x27; ], styleResources: &#123; less: &#x27;@/assets/vars.less&#x27; &#125; ...&#125; 全局标量有多个的话，可以改成数组的形式 scss安装依赖，这里安装依赖需要指定版本，不然会报错，nuxt版本问题不兼容。 1npm install -D sass-loader@^10 sass","categories":[{"name":"SSR","slug":"SSR","permalink":"https://jishuyao.cn/categories/SSR/"}],"tags":[{"name":"Nuxt","slug":"Nuxt","permalink":"https://jishuyao.cn/tags/Nuxt/"}]},{"title":"Nuxt2安装","slug":"Nuxt2安装","date":"2022-12-18T13:27:53.000Z","updated":"2022-12-19T08:43:29.163Z","comments":false,"path":"2022/12/18/Nuxt2安装/","link":"","permalink":"https://jishuyao.cn/2022/12/18/Nuxt2%E5%AE%89%E8%A3%85/","excerpt":"","text":"npx 1npx create-nuxt-app 项目名 yarn 1yarn create nuxt-app 项目名 目录结构 assets用于组织未编译的静态资源，比如less、sass、javascript。 components用于组织应用的vue.js组件。这些组件不会像页面组件那样有asyncData方法的特性。 layouts用于组织应用的布局组件。 middleware目录用于存放应用的中间件。 page用于组织应用的路由及视图。Nuxt.js会读取该目录下所有的.vue文件并自动生成对应的路由配置。 plugins用于组织那些需要在根vue.js应用实例化之前需要运行的javascrips插件。 static用于存放应用的静态文件，此类文件不会被Nuxt.js调用webpack进行构建编译处理。服务器启动的时候，该目录下的文件会映射至应用的根路径&#x2F;下 store用于组织应用的vuex状态树文件。Nuxt.js 框架集成了 Vuex状态树 的相关功能配置，在 store 目录下创建一个 index.js 文件可激活这些配置。 nuxt.config.js文件用于组织Nuxt.js应用的个性化配置，以便覆盖默认配置。 package.json文件用于描述应用的依赖关系和对外暴露的脚本接口。","categories":[{"name":"SSR","slug":"SSR","permalink":"https://jishuyao.cn/categories/SSR/"}],"tags":[{"name":"Nuxt","slug":"Nuxt","permalink":"https://jishuyao.cn/tags/Nuxt/"}]},{"title":"git常用命令","slug":"git常用命令","date":"2022-12-18T13:24:29.000Z","updated":"2022-12-19T08:43:29.165Z","comments":false,"path":"2022/12/18/git常用命令/","link":"","permalink":"https://jishuyao.cn/2022/12/18/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"本地初始化仓库1git init 克隆远程仓库1git clone 远程仓库地址 克隆某个分支的代码到本地1git clone -b 分支名 远程仓库地址 查看本地git状态1git status 将某个文件或所有文件添加暂存区12git add 文件名 // 将某个文件添加暂存区git add . // 将所有文件添加暂存区 插销对某个文件的修改1git checkout -- file 提交暂存区的文件1git commit -m 备注信息 快捷指令查看git常用命令1git helper -a 逐行查看某个文件的修改历史12git blame 文件名 // 查看该文件的修改历史git blame -L 100,10 文件名 // 从100行开始，到110行 逐行查看文件的修改历史 清除1234git clean -n // 列出打算清除的档案(首先会对工作区的内容进行提示)git clean -f // 真正的删除git clean -x -f // 连.gitignore中忽略的档案也删除git status -sb (sb是 short branch) // 简洁的输出git status中的信息 删除放入暂存区文件的方法（已经提交之后的）12git rm 文件名 // 将该文件从commit后撤回到add后git reset HEAD^ --hard // 删除后 可以用git rm 文件名再回撤一步 修改文件名以及移动12git mv a b // 把a文件名字改成b 并且直接放入git add后的暂存区git mv b ./demos/ // 把b文件移动到demos文件夹下 对比工作区、暂存区、仓库的差异12345678git diff // 查看变更 工作区与暂存区的差异比对git diff --cached // 暂存区与提交版本的差异git diff HEAD // 工作区与仓库中最后一次提交版本的差别git diff 版本哈希值 版本哈希值 // 查看这2个版本哈希之间的区别或者 git diff HEAD~数字 HEAD~数字 git diff tt 就是倒数第5个版本与第一个版本之间的差异git diff --cached tt 暂存区与倒数第5个版本之间的比对 查看提交信息1234git show HEAD // 查看最后一次提交修改的详细信息 也可以用git show 哈希值 查看对应的内容git show HEAD^ // 查看倒数第二次的提交修改详细信息git show HEAD^^ 或者git show HEAD~2 查看前2次变更git show HEAD 或 git show 哈希值 或者git show tag(标签名) 都可以查看最近一次提交的详细信息 查看信息123456789git log --pretty=format:&#x27;%h %ad | %s%d [%an]&#x27; --graph --date=short// 获取git log里的树形详细信息 包括hasg 日期 提交信息 提交人等git log --oneline //拉出所有提交信息 q是退出git log -5 // 查看前5次的提交记录git log --oneline -5 // 打印出的日志里面只有哈希值和修改的内容备注git log 文件名 // 查看该文件的提交git log --grep // 想过滤看到的内容 过滤日志git log -n // 查看近期提交的n条信息内容git log -p // 查看详细提交记录 改写历史提交，把多次提交合并起来1git rebase -i HEAD~3 变基之后的哈希值与之前的不同 证明变基是重新做的提交 把多次提交合并成了几次提交 回滚1234567891011121314git commit --amend -m &quot;提交信息&quot; // 回撤上一次提交并与本次工作区一起提交git reset HEAD~2 --hard // 回撤2步git reset --files // 从仓库回撤到暂存区git reset HEAD // 回撤暂存区内容到工作目录git reset HEAD --soft 回撤提交到暂存区git reset HEAD --hard // 回撤提交 放弃变更 (慎用)git reset HEAD^ // 回撤仓库最后一次提交git reset --soft HEAD^ // 将执行git commit 并没有执行git push到远程仓库的内容 回撤到工作区 并且保存在工作区git reset --hard HEAD^ // 将执行git commit 并没有执行git push到远程仓库的内容 回撤并且不保存// 注意 在window电脑端 可能会出现执行git reset --hard HEAD^命令时 提示More? 所以针对windows 我们回撤内容需要键入git reset --hard HEAD^^才可以 如果我们git commit提交2次 想把2次都回撤到工作区保存 可以使用git reset --soft HEAD~2git reset --hard commitid // 回撤到该次提交id的位置 回撤后本地暂存区可能有内容 本地仓库有要同步的内容 此时 丢弃掉暂存区的内容 并且强制将本地的内容推送至远程仓库 执行下面的命令 git push -u -f origin 分支名 这样就可以完全回撤到提交id的位置git reset --soft commitid // 回撤到该次提交id的位置 并将回撤内容保存在暂存区git push -f -u origin 分支名 所有内容都回撤完了 将回撤后的操作强制推送到远程分支git push origin/分支名 --force 强制将本地回撤后的操作 强制推送到远程分支 标签123456789101112131415161718192021git tag // 查看列出所有打过的标签名 例如V1.1 V1.11 V1.12 V1.13等git tag -d 标签名 // 删除对应标签 只是删除了本地的git push origin :refs/tags/远程标签名 // 删除远程仓库的标签 可以在删除本地标签后 执行这个操作 同步远程git tag 标签名字 // 在当前仓库打个标签git tag 标签名 commitid // 给已知提交id的版本打标签 例如git tag v1.1.1 6f8f25fcf57a17e6c72b33f6bca0797fab15ff8b // 给历史提交打V1.1.1的tag标签 这里的commitid可以缩写 缩写成前6位就可以 例如git tag V1.1.1 6f8f25 一样可以给这个提交id打上taggit tag -l // 过滤tag 例如 git tag -l &quot;V1.1*&quot; // V1.1 V1.11 可以过滤前面是V1.1开头的内容git show 标签名称 // 查看tag的详细信息 包括commitid 作者信息 日期 内容git push origin 标签名称 // 同步这个tag到远程服务器 默认tag是打在本地的 这个命令可以把它推到远程git push origin --tags // 将本地所有tag推送到远程服务器git pull --tags // 把远程仓库的标签也拉取下来git tag foo -m &quot;message&quot; // 在当前提交上，打标签foo 并给message信息注释git tag 标签名 哈希值 -m &quot;message&quot; // 在某个哈希值上打标签并且写上标签的信息git tag foo HEAD~4 // 在当前提交之前的第4个版本上 打标签foo git stash // 把暂存区的内容 暂时放在其他中 使暂存区变空git stash list // 查看stash了哪些存储git stash pop // 将stash中的内容恢复到当前目录，将缓存堆栈中的对应stash删除git stash apply // 将stash中的内容恢复到当前目录，不会将缓存堆栈中的对应stash删除git stash clear // 删除所有缓存的stashgit reset --hard // 回撤git stash pop的内容 分支12345678910111213141516171819202122232425git branch 分支名 // 新建分支git branch // 查看当前所有分支git checkout 分支名 // 检出分支git checkout -b 分支名 // 创建并切换分支git checkout commitId 文件名（文件路径下的文件名） 还原这个文件到对应的commitId的版本（例如src/page/attendance/attendanceSum.vue我想把它还原到2个版本之前 首先git log src/page/attendance/attendanceSum.vue找到对应想要还原的版本复制版本提交的commitID 然后执行git checkout commitID src/page/attendance/attendanceSum.vue这样就把attendanceSum.vue这个单个文件 还原到了对应版本）git branch -v // 查看分支以及提交hash值和commit信息git merge 分支名 // 把该分支的内容合并到现有分支上git cherry-pick commitId // 把其他分支的某一次提交内容合并到当前分支 这个在我们平时多分支开发中很常用git branch -d 分支名 // 删除分支git branch -D 分支名 // 强制删除 若没有其他分支合并就删除 d会提示 D不会git branch -m 旧分支名 新分支名 // 修改分支名git branch -M 旧分支名 新分支名 // 修改分支名 M强制修改 若与其他分支有冲突也会创建(慎用)git branch -r // 列出远程分支(远程所有分支名)git branch -a // 查看远程分支(列出远程分支以及本地分支名 远程分支会以remote/origin/分支名这种形式展示 红色标识)git branch // 查看本地分支git reflog show --date=iso &lt;branch name&gt; // 查看分支创建时间 例如git reflog show --date=iso origin/feature-PCDEC-6375 输出 88e22885 (HEAD -&gt; feature-PCDEC-6375, origin/feature-PCDEC-6375, origin/EC-master, EC-master) refs/remotes/origin/feature-PCDEC-6375@&#123;2021-07-27 11:31:23 +0800&#125;: fetch: storing head 创建时间就是2021-07-27 11:31:23git fetch // 更新remote索引git push -u origin 分支名 // 将本地分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push 也可解决 git建立远程分支关联时出现fatal ... upstram的问题git push origin --delete 分支名 (将git branch -D 分支名 删掉的分支 同步到远程主机 将origin/分支名的该分支也删除掉)git remote show origin 查看remote地址，远程分支，还有本地分支与之相对应关系等信息(结合git branch -a使用)git remote prune origin 删除远程仓库不存在的分支 (git branch -a使用)git reflog show --date=iso 分支名 // 查看指定分支的创建时间 以及更改记录等 仓库迁移1234567// 首先在当前项目主分支先执行git pull 把代码更新为最新git remote set-url origin &lt;新的仓库名&gt;git push -u -f origingit push -u -f origin --all // 把所有分支迁移过去git push -u -f origin --tags // 把所有tag迁移过去// 然后去拉取新的仓库代码就可以了 如果新仓库之前拉取过了重新仓库迁移 里面分支没同步的话 执行 git fetch试一下 同步过来 强制推送1git push -- force 打开git GUI1gitk // 用git命令快速打开git GUI config以及配置1234567git config --list // 获取config信息git config --global core.safecrlf false // 去掉git add 命令后 出现的一堆CR LF提示信息其中CR是回车的意思 LF是换行git config --global user.name&quot;your name&quot; // 设置usernamegit config --global user.email&quot;your_email@youremail.com&quot; // 设置邮箱git config --global credential.helper wincred // 存储凭证 (可用于输入一次用户密码后，不再输入 有时我们已经用SSH key 绑定关联好了 但是每次git提交的时候 还是需要你输入用户名密码 在这个时候 敲入这个命令 将凭证存储起来 用户名密码就不需要再次输入了)git config --global alias.ci commit // 将commit命令设置别名ci git commit命令将由git ci来代替","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://jishuyao.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://jishuyao.cn/tags/Git/"}]}],"categories":[{"name":"windows","slug":"windows","permalink":"https://jishuyao.cn/categories/windows/"},{"name":"前端开发","slug":"前端开发","permalink":"https://jishuyao.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Node","slug":"前端开发/Node","permalink":"https://jishuyao.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Node/"},{"name":"webpack","slug":"webpack","permalink":"https://jishuyao.cn/categories/webpack/"},{"name":"CSS","slug":"CSS","permalink":"https://jishuyao.cn/categories/CSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://jishuyao.cn/categories/JavaScript/"},{"name":"React","slug":"React","permalink":"https://jishuyao.cn/categories/React/"},{"name":"JavaScript","slug":"前端开发/JavaScript","permalink":"https://jishuyao.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"},{"name":"SSR","slug":"SSR","permalink":"https://jishuyao.cn/categories/SSR/"},{"name":"开发工具","slug":"开发工具","permalink":"https://jishuyao.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://jishuyao.cn/tags/windows/"},{"name":"node","slug":"node","permalink":"https://jishuyao.cn/tags/node/"},{"name":"Node","slug":"Node","permalink":"https://jishuyao.cn/tags/Node/"},{"name":"前端开发","slug":"前端开发","permalink":"https://jishuyao.cn/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"webpack","slug":"webpack","permalink":"https://jishuyao.cn/tags/webpack/"},{"name":"CSS","slug":"CSS","permalink":"https://jishuyao.cn/tags/CSS/"},{"name":"Vue","slug":"Vue","permalink":"https://jishuyao.cn/tags/Vue/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://jishuyao.cn/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://jishuyao.cn/tags/React/"},{"name":"Mobx","slug":"Mobx","permalink":"https://jishuyao.cn/tags/Mobx/"},{"name":"Nuxt","slug":"Nuxt","permalink":"https://jishuyao.cn/tags/Nuxt/"},{"name":"Git","slug":"Git","permalink":"https://jishuyao.cn/tags/Git/"}]}